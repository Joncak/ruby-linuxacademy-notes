{"name":"Ruby-linuxacademy-notes","tagline":"Notas del Curso con repo de los proyectos.","body":"[TOC]\r\n\r\n# Getting Ready to Code\r\n## Course Overview \r\n * Lo da un instructor que no habia visto antes.\r\n * Es bastante Completo.\r\n## What's a Programming Language?\r\n* binary es lo que lee el procesador, despues hicieron asembly pero este fue reemplado por Fortran y Cobol\r\n* C y C++ son Compiled Languages mientras que Ruby, php, javascript son Scripting languages\r\n* Existen 2 styles de Programar o la manera de organizarse el codigo \r\n\t- Procedular es similar a los script corren desde el comienzo al final \r\n\t- Object Oriented; son objetos se definen maneras de manipularlo\r\n* Ruby pertenece a los 2 estilos pero es facil de leer,\r\n* Uno de los framework mas famosos de ruby es ruby on rails\r\n* El curso esta enfocado en scripting task.\r\n## Installing Ruby \r\n* Existen 2 maneras de instalar ruby \r\n\t- Packages managers \r\n\t\t- **Centos**  `yum install ruby irb rubygems`\r\n\t\t- **Ubuntu** `apt-get install ruby`\r\n\t- RVM \r\n\t\t- el cual es un proceso manual pero con mas opciones.\r\n\t\t- Para instalar RVM buscamos en su pagina [rvm.io](rvm.io) y lo descargamos luego lanzamos; `rvm install ruby`\r\n## The Ruby Environment\r\n* Los  archivos de scripts son .rb\r\n* Usaremos 3 programas con ruby \r\n\t- ruby: compilador \r\n\t- irb: shell  \r\n\t- gem: instalador de extensiones y plugins.\r\n* puts == echo e igual es recomendable usar el shibang para evitar usar el `ruby example.rb`\r\n* IRB es una shell como la que tiene python donde todos los comandos se comunican con el compilador.\r\n* cuando sale => nill es totalmente normal.\r\n* gems es util para instalar librerias, y muchas funcionalidades extras.\r\n# Learning Basic Ruby Syntax\r\n## Hello World! \r\n*  puts es un method y el Hello word es un argumento\r\n*  Methods= encapsulate code can use arguments\r\n* Para multiples arguments separarlos con \",\"\r\n* Otra forma es usando **();** example; `puts(\"Hello World\")`\r\n## Variables \r\n* Crear las variables es muy similar a otros lenguajes pero añade nuevas clasificaciones.\r\n* Existen varias variables que pueden empezar con @ o @@ incluso $\r\n* Las vaiables pueden ser; locales, instance, certain places,\r\n* ademas de variables existen constantes que no pueden cambiar y empiezAN con MAYUSCULA.\r\n* esta manera de declarar variables solo funciona para numeros. a no ser que usemos ' ' para string.\r\n## Types of Variables\r\n* Existen 2 varios tipos de variables \r\n\t- Litterals = le damos valores explicitamente \r\n\t- Variables= los cuales son link a valores.\r\n* Los mas famosos son:  \r\n\t- **numbers:** en los numbers existen integers y floats, dentro de Integers existe bignum o fixnum\r\n\t- **booleans:** son los tipicos true o false.\r\n\t- **strings:** son los textos \r\n\t- **arrays:** su caracteristica es que son filas y estas pueden ser acumuladas pero colocadas al final si no se quiere reemplazar al anterior.\r\n\t\t- ex: `array = [1,2,3]`\r\n\t\t- en caso de añadir otro mas usamos `array [3]= 4`\r\n\t\t- En algunos casos es necesario crear un array limpio primero.\r\n\t\t- todos los valores deben estar en el `[]` y separarse por `,`\r\n\t- **hashes:** similas al array pero en vez de listar por numeros listamos por keys\r\n\t\t- `my_hash = \"string\" => \"my string\", \"my number\" => 4` luego llamamos con `my_hast [\"simple string\"]`\r\n* Podemos asignar un valor a un array o hash existente puede crearse vacio con `my array []`\r\n## Basic Math\r\n* las math son las nomales pero existe una % que es modulus no se que hace.\r\n* si existe una variable podemos llamarla sin los `\"\"` o `''`\r\n* podemos convertir diferentes variables por ejemplo de numbers to string.\r\n* `.to_s`  a String.\r\n* `.to_i`  a entero o integer.\r\n* `.to_f` to float o decimal \r\n\t* ex: ```irb(main):001:0> 12.to_f\r\n=> 12.0\t\t\t```\r\n## Conditionals\r\n* Los conditionals son buenisimos.\r\nex:\r\n```ruby  \r\n if my_variable > 10\r\nputs my_variable\r\nend\r\n```\r\n* los extended conditional es cuando añadimos un **else**, el cual corre si la condicion es falsa.\r\n* tambien podemos usamos **elsif** que permite añadir otro if si la primera condicion es falsa.\r\n* En ruby podemos usar conditionals en una sola linea por ejemplo\r\n`puts \"Big Number\" if my_variable > 10`\r\n`puts \"Small Number\" unless my_variable > 10`\r\n* la condicion **unless** tambien podemos usarla y es una negacion hasta que ocurra.\r\n```ruby\r\nunless my_variable > 10\r\n\tputs my_variable\r\nend \r\n```\r\n* Otra forma de hacerlo en una linea es usando la **Ternary Statement**\r\n\t* Regular Statement.\r\n```ruby \r\nif my_variable > 10\r\n\tputs \"big\"\r\nelse \r\n\tputs \"small\" \r\nend \r\n```\r\n\t* Ternary Statement \r\n`my_variable > 10 ? puts(\"big\") : puts(\"small\")`\r\n **#donde el `?` seria un **if** y el `:` un **else**, es necesario usar parentesis.**\r\n* tambien existen los comparison tests donde\r\n\t- a > b \r\n\t- a < b\r\n\t- a >= b\r\n\t- a <= b \r\n\t- a == b\r\n* Un ex de un script con condiciones.\r\n```ruby\r\nputs \"Input an integer\"\r\nuser_input = gets.to_i\r\nif user_input > 10\r\noutput = user_input * user_inpu\r\nelse\r\noutput = user_input * 2\r\nend\r\nputs output\r\n```\r\n## Conditionals Continued\r\n* Un script puede tener varios elsif de ser necesario. \r\n* ![Puedes tener varios elsif](https://i.imgur.com/mwL2jhB.png)\r\n* Pero es posible usar case que es mucho mas facil de leer.\r\n![enter image description here](https://i.imgur.com/MhtxIPN.png)\r\n* Es posible añadir multiples conditionals \r\n\t* Boolean AND\r\n   ` if my_var == 10 && your_var == 5` Aca se tienen que cumplir los 2 para que se pueda correr.\r\n\t* Boolean OR \r\n\t`if my_var ==10 || your_var == 5` Aca si cualquier de los 2 es verdadero el statement se aplica.\r\n\t* Boolean NOT\r\n\t`if my_var != 10` Si no es igual se lanza el statement.\r\n\t* Ejemplo con condicionales. \r\n```ruby\r\n!#/usr/bin/ruby\r\n\r\nputs \"En tu escritorio tienes un Telefono (Y/N)\"\r\ncase gets\r\n        when \"Y\\n\"\r\n                phone  = true\r\n        when \"N\\n\"\r\n                phone = false\r\nend\r\nputs \"En tu escritorio tienes un lapiz (Y/N)\"\r\ncase gets\r\n        when \"Y\\n\"\r\n                pencil  = true\r\n        when \"N\\n\"\r\n                pencil = false\r\nend\r\nputs \"You have a phone\" if phone\r\nputs \"You have a pencil\" if pencil\r\n```\r\n## Iterators \r\n * Los iterators son ideales para operar cada miembro de una variable por ejemplo los array si quisieramos mostrar cada miembro de un array seria como: \r\n \r\n **Whitout Iterators**\r\n\t `puts first_five_integers [0]`\r\n\t `puts first_five_integers [1]`\r\n\t `puts first_five_integers [2]`\r\n\t `puts first_five_integers [3]`\r\n\t `puts first_five_integers [4]`\r\n\t \r\n **Con Iterators seria mucha mas sencillo**\r\n```ruby\r\nfirst_five_integers.each do |my_integer| \r\n\tputs my_integer \r\nend \r\n```\r\n* Como each es considerado un Method puede usar arguments pero en este caso el puede usar un block como argument para que tome el block of code debemos colocarlo entre do y end \r\n*  Tambien es posible suplir una variable al block con each definiendola entre | | despues del do y tendra el valor de cada miembro del array.\r\n*  Los iterators actuan como loops para collections.\r\n* DRY = Do not Repeat Yourself \r\n* El earch puede ser usado en un hash y se pueden suplir 2 variables la key y el value.\r\n```ruby\r\nmy_hash = {\"orange\" => true, \"banana\" => false}\r\nmy_hash.each do | key,value | \r\n...\r\nend \r\n```\r\nEjemplo de una lista de Compras \r\n```ruby\r\n#!/usr/bin/ruby                                                                                                                                       \r\n# Declaramos el Hash con los Valores que queramos incluir.                                                                                            \r\ngrocery_items = { \"oranges\" => false, \"bananas\" => false}                                                                                             \r\n#Preguntamos lo que necesitamos usando el Iterator y suplimos 2 variables item y need_for_item.                                                       \r\nputs \"Do you need:\"                                                                                                                                   \r\ngrocery_items.each do | item, need_for_item | # Aqui solo declaramos y preparamos las variables.                                                      \r\n  puts item + \"? (Y/N)\" #Aqui es donde preguntamos.                                                                                                   \r\n  case gets                                                                                                                                           \r\n    when \"Y\\n\"                                                                                                                                        \r\n      grocery_items [item] = true                                                                                                                     \r\n    when \"N\\n\"                                                                                                                                        \r\n      grocery_items [item] = false                                                                                                                    \r\n  end                                                                                                                                                 \r\nend                                                                                                                                                   \r\nputs \"Here's your list:\"                                                                                                                              \r\ngrocery_items.each do | item, need_for_item |                                                                                                         \r\n  puts item if need_for_item #Aqui aun no entiendo pero supongo que si es true se cumple la sentencia.                                                \r\nend    \r\n```\r\n## Arrays and Hashes\r\n* Podemos usar nested arrays los cuales se llaman multi.dimensional arrays. \r\n`childhood_games_played  = [[\"make believe\", true], [\"tag\", false]]`\r\n* Luego para llamar a los juegos debemos usar \r\n```ruby\r\nchildhood_games_played [0][0]\r\n\t\"make believe\"\r\nchildhood_games_played [1][0]\r\n\t\"tag\"\r\nchildhood_games_played [0][1]\r\n\t\"true\"\r\nchildhood_games_played [1][1]\r\n\t\"false\"\r\n```\r\n* Los hashes tambien pueden ser nested.\r\n`cocktails = {\"martini\" => {\"vodka\" => true, \"gin\" => false}}`\r\n* Luego para llamarlos usamos \r\n```ruby \r\ncocktails[\"martini\"][\"vodka\"]\r\n\ttrue\r\ncocktails[\"martini\"][\"gin\"]\r\n\tfalse \r\n```\r\n* Podemos ordenar los array con el method **.sort**\r\n`my_array.sort` devuelve un array ordenado.\r\n* En caso de querer ordenar el array en uso usamos `mv_array.sort!`\r\n* Es posible al igual que con each usarlo en block of codes \r\n```ruby\r\nmy_array.sort do |a,b| \r\n\r\n\ta <=> b #Diferencia quien esta primero.\r\n\t\r\nend \r\n```\r\n* Para saber la longitud de un array es posible usar los method \r\n\t**.count**\r\n\t**.length**\r\n* Para revisar si en el array existe un valor es posible usar el method **.include**\r\n`first_five_integers.include? 1` Es importante usar el ? \r\n* Es posible crear un array a partir de otro usando **.map** un buen ejemplo es para calcular si unos numeros de un array son pares o impares.\r\n```ruby\r\nmy_array = [1,2,3]\r\nodd_or_even = my_array.map do |element|\r\n\telement % 2 == 0 ? \"even\" : \"odd\"\r\n\tend  \r\n```\r\n## Strings \r\n* Se deben colocar las String en `\"\"` para que ruby pueda identificarlas.\r\n*  Llamar las variables es diferente que en bash para llamar una variable entre strings usamos #{variable}\r\n`puts \"Your have #{bank_account} dollars.\"`Sin necesita de cerrar los \" podemos incluir la variable e imprimir en una sola linea.\r\n* Podemos sumar operaciones matematicas dentro de lo {} \r\n`puts \"Tiene en total #{banesco + bod}bs. entre todas sus cuentas.\"`\r\n* Podemos sumar string con string en caso de ser string y integers daria error.\r\n* En caso de querer cambiar el string a Capital usamos **.upcase** si fuera a lower seria **.downcase**\r\n* En caso de dividir una string usamos **.split(\" \")** donde el space es el delimitador luego se convertiria en un array.\r\n* Un pequeño ejemplo\r\n```ruby\r\nputs \"Insertar una frase\"\r\npalabra = gets\r\nnumero_palabras = palabra.split(\" \").count\r\nputs \"Tu frase tiene #{numero_palabras} palabra#{numero_palabras == 1 ? \".\" : \"s.\"}\"\r\n```\r\n## While Loop\r\n* Repite una seccion del codigo hasta que una condicion sea cierta, para evitar que sea un loop infinito la variable debe cambiar.\r\n* La syntax seria while condition do y un end es bueno añadir un contador al final de la sentencia ex: my_integer += 1 \r\n```ruby\r\nmy_var = 10\r\n\r\nwhile my_var < 30 do \r\n\tputs \"my_var = #{my_var}\"\r\n\tmy_var += 1 \r\nend \r\n```\r\n* El program block va entre el do y el end. \r\n* Es importante saber que si usamos \" \" no podemos llamar una variable a no ser que usemos el #{}.\r\n* loops and arrays: the perfect match.\r\n* El until loop es totalmente inverso.\r\n* Un ejemplo de ordenar los enteros.\r\n```ruby\r\nintegers = []\r\ncurrent_integer = 0 \r\nwhile current_integer < 10 do \r\nputs \"Type an integer\"\r\nintegers[current_integer] = gets.to_i\r\n\tcurrent_integer+=1\r\nend \r\n\r\nintegers.sort.each do |this_int|\r\n\tputs this_int\r\nend \r\n```\r\n## For Loop\r\n* El For loop es igual al method each. \r\n* un ejemplo practico seria.\r\n```ruby \r\nbags = [\"suitcase\", \"messenger bag\", \"satcher\", \"backpack\"]\r\nfor bag_types in bags do\r\n\tputs bag_type\r\nend\r\n```\r\n* los for loop no solo pueden usarse en una collection es posible usarse en rangos \r\n* Existen 2 tipos de rangos Inclusive y Exclusive la diferencia es que en Exclusive se excluye el ultimo valor del rango.\r\n\r\n```ruby\r\n#inclusive range:\r\n\tfor variable in 1..4 do\r\n\t\t...\r\n\tend \r\n```\r\n```ruby\r\n#Exclusive range:\r\n\tfor variable in 1...4 do\r\n\t\t...\r\n\tend \r\n```\r\n* Es recomendable dejar de usar for loop y usar **.each** \r\n## Loop Control \r\n* Con el key **next** podemos saltar las demas interacciones del loop y saltar a la proxima iteracion.\r\n```ruby\r\nmy_var = 0\r\nwhile my_var < 10 do\r\n\tif my_var == 3 \r\n\t\tmy_var += 1 \r\n\t\tnext\r\n\tend \r\n\tputs my_var\r\n\tmy_var += 1\r\nend\r\n```\r\n* Creo que salta a una proximo block.\r\n* La key **redo** va al comienzo del codigo asi la condicion sea verdadera o falsa.\r\n```ruby\r\nmy_var = 0\r\nwhile my_var < 10 do\r\n\tputs my_var\r\n\tif my_var == 3 \r\n\t\tmy_var = 10 \r\n\t\tredo\r\n\tend \r\n\tmy_var += 1\r\nend\r\n```\r\n* Seria como un if exit en bash.\r\n* Lo extraño es que el redo seguira corriendo asi el statement del while sea falso....\r\n* El redo no le veo mucho sentido.\r\n* El key **break** sale del loop inmediatamente y es uno de los mas importantes.\r\n```ruby\r\nputs \"Type something to continue. Or nothing to quit\"\r\nwhile a = gets do\r\n\r\n\tif a ==\"\\n\" \r\n\t\tbreak\r\n\tend \r\n\tputs a #Imprime la misma linea vacia.\r\nend \r\n```\r\n* Ejemplo final\r\n```ruby\r\ntotal = 0 \r\nputs \"Input your numbers\" \r\nwhile input = gets do #Declaramos \r\n\tif input == \"\\n\" \r\n\t\tbreak \r\n\tend \r\n\ttotal = total + input.to_f \r\n\tputs \"running total = #{total}\" \r\nend \r\n\r\nputs \"Total: #{total}\" \r\n```\r\n## Methods \r\n* Los Methods son como funtions en otro lenguaje antiguo\r\n![enter image description here](https://i.imgur.com/AipGJrz.png)\r\n*  Method Example\r\n```ruby\r\ndef hello_user \r\n\tputs \"Enter your Name\" \r\n\tusername = gets\r\n\tputs \"Hello \" + username\r\nend \r\n\r\nhello_user #Llamamos al metodo.\r\n```\r\n* Los methods devuelven objects.\r\n* En el irb podemos definir los scripts tal cual y cuando cambiemos de 001:0 a 002:1 es porque estamos dentro de un statement.\r\n* Por defecto un method puede arrojar un nil pero esto puede cambiar\r\n```ruby\r\ndef hello_user \r\n\tputs \"Enter your Name\" \r\n\tusername = gets\r\n\t\"Hello #{username.chop}.\" \r\nend \r\nhello_user\r\n```\r\n* Esta vez debe arrojar el object del username.\r\n* Es util cuando un method arroja un boolean.\r\n```ruby\r\ndef hello_user \r\n\tputs \"Enter your Name\" \r\n\tusername = gets\r\n\tif username != \"\\n\" \r\n\t\t\"Hello #{username.chop}.\"\r\n\telse\r\n\t\tfalse \r\nend\r\n```\r\nEjemplo de unas recetas de comida.\r\n```ruby\r\ndef get_ingredient\r\n\tnew_ingredient = gets\r\n\tif new_ingredient != \"\\n\"\r\n\t\tnew_ingredient \r\n\telse \r\n\t\tfalse\r\n\tend\r\nend\r\ningredients = [] \r\nputs \"Input your Ingredients\"\r\nwhile my_ingredient  = get_ingredient do  #Comparamos que sea una string.\r\n\tingredients[ingredients.count] = my_ingredient\r\nend \r\nputs \"Input your instructions\"\r\ninstructions = gets\r\nputs \"Ingredients:\"\r\nputs ingredients\r\nputs \"Instructions:\"\r\nputs instructions\r\n\r\n```\r\n## Methods Continued\r\n* Es posible usar metodos en un argumento.\r\n![enter image description here](https://i.imgur.com/G8BiPcK.png)\r\n* Es recomendable declarar el method seguido de declarar la variable que se usara como argumento.\r\n* Para doblar un numero seria my_var **  *=2**\r\n* El yield seria como el punto de stdin en donde el method introduce su resultudado.\r\n```ruby\r\ndef my_method \r\n        puts \"executing your code...\"\r\n        yield\r\n        puts \"done\"\r\nend\r\nmy_method do  \r\n        puts 2 + 2 \r\nend \r\n\r\n######RESULTADO#########\r\nexecuting your code...\r\n4\r\ndone\r\n```\r\n* Ejercicio que multiplica 2 numeros.\r\n```ruby\r\ndef multiply_this a. b\r\n\ttotal = a * b \r\n\tif total < 0 \r\n\t\tfalse\r\n\telse\r\n\t\ttotal\r\n\tend\r\nend\r\n\r\nuser_input = []\r\nputs \"Input two numbers\" \r\nwhile user_number = gets do\r\n\tuser_input[user_input.count] = user_number.to_f \r\n\tif user_input.count == 2 \r\n\t\tbreak \r\n\tend\r\nend \r\nif result = multiply_this(user_input[0], user_input[1]) #Declara una variable en el mismo statement\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#Arroja los argumentos al method desde un array.\r\n\tputs result \r\nelse \r\n\tputs \"Invalid Input\"\r\nend\r\n```\r\n## Using Classes\r\n* Se podria definir a una clase con una descripcion de un objeto.\r\n*\r\n![enter image description here](https://i.imgur.com/lLDtoa4.png)\r\n* En ruby todo es un object por tanto todo pertenece a una clase.\r\n* Array, Hash, y todos los tipos de variables son clases.\r\n* Podemos decir que **my_array = [ ] == my_array = Array.new** \r\n* Las clases pueden contener dos tipos de cosas; variables definitions y method definitiios por ejemplo la class array incluye el method each. \r\n* Las instances al parecer representan un objeto en especifico en vez de tipos de objetos.\r\n* La mayor ventaja es que puedo tener multiples instancias de una misma clase.\r\n`my_first_array = Array.new`\r\n`my_second_array = Array.new`\r\n* Las clases pueden incluir propiedades de otras clases.\r\n* Si usamos **.class** revelara a que clase pertenece pero si usamos **.superclass** revelara la clase de quien hereda.\r\n![enter image description here](https://i.imgur.com/IlDo4qI.png)\r\n* Vemos que si usamos el 1.class.superclass.superclass.superclass vemos es un Object como todo en ruby.\r\n## Creating Classes \r\n* Para crear una class la syntax seria\r\n`class Class_name `\r\n`...`\r\n`end`\r\n* Es importante que la clase este escrita en Mayuscula.\r\n* Para inicializar un object es importante que la clase ya estre creada.\r\n`my_object = Class_name.new`\r\n* attr_accesor = attribute accesor el cual es un method para crear ins\r\n* Ejemplo de como crear una tabla\r\n```ruby\r\nclass Table \r\n\tattr_accessor :height, :width, :length\r\nend\r\n```\r\n* el attr_accesor crea method para acceder a la data que le damos como argumento \r\n* El accesor crea una instance variable que son las creadas con @variable\r\n* Cada vez que creemos clases crearemos instance variable dentro de ellas.\r\n* Es importante saber que crea method para acceder a esas instance variables donde ese method corresponde al nombre.\r\n* Cada vez que usamos `:` se crea un **symbol** en ruby.\r\n* Podemos crear una class en un archivo y luego llamarla desde irb con `irv -r ./table.rb`\r\n* cuando usamos `t = Table.new` estamos creando una instancia de la clase.\r\n* Luego podemos colocar datos en la instancia t siguiendo de la instance variable ex: `t.height = 5`\r\n* Es posible extender una Class ya creada usando el class con el nombre de la class y añadiendo lo nuevo dentro.\r\n* en este caso la extendemos para introducir un nuevo method.\r\n```ruby\r\nclass Table\r\n\tdef cost\r\n\t\t@length * @width * 5 + 4 * @height * 2 \r\n\tend\r\nend\r\n```\r\n* Vemos como llamamos nuestras variables con @ al ser Instance variables.\r\n* Luego podemos llamar a la instancia que llamamos que se llama con el method que definimos al final **t.cost** \r\n## Creating Classes Continued\r\n* Es posible definir un initialize method cada vez que instanciamos o instanstiate una class y colocarles unos valores por defecto.\r\n* Ejemplo\r\n```ruby\r\nclass table \r\n\tdef initialize ilength = 3, iwidth = 3, iheight = 3\r\n\t\t@lenght = ilength\r\n\t\t@width = iwidth\r\n\t\t@height = iheight\r\n\tend\r\nend\r\n```\r\n*  Es importante saber que estamos extendiendo la class Table de la antigua clase por eso existe @lenght y los otros.\r\n* Despues cuando inicializamos la clase con .new tendremos los valores 3 o incluso podemos añadir nuevos valores manteniendo los ordenes.\r\n![enter image description here](https://i.imgur.com/YPgV8g0.png)\r\n* Si usamos el private dentro de un method solo sera accesible para la class code no fuera de ella.\r\n* Luego si usaramos **my_table.table_top_area** nos daria error al llamar a un method privado.\r\n* Por defecto todas las clases heredan de la clase object. en caso de querer heredar de otra usamos \r\n* `class LibraryTable  < Table` al momento de declarar la clase de esta manera podemos llamar a los private method.\r\n* Al igual que el private existe el protected que es usado para comparar al asegurar que el method solo es acedido desde sibling object o child objects\r\n* Ejercicio de Cuenta Bancaria.\r\n```ruby\r\nclass AccountBook\r\n\tdef initialize \r\n\t\t@ledger = []\r\n\t\t@current_total = 0 \r\n\tend \r\n\tdef add_money amount, memo = \"\"\r\n\t\t@ledger[@ledger.count] = [amount, memo]\r\n\t\t@current_total += amount\r\n\tend\r\n\tdef subtract_money amount, memo =\"\"\r\n\t\t@ledger[@ledger.count] = [amount * -1, memo]\r\n\t\t@current_total -= amount\r\n\tend\r\n\t\r\n\tdef printout \r\n\t\ttab = 0\r\n\t\tputs \"Amount:\\tMemo:\\tTotal:\"\r\n\t\t@ledger.each do |line|\r\n\t\t\ttab += line[0]\r\n\t\t\tputs \"#{line[0]}\\t#{line[1]}\\t#{tab}\"\r\n\t\tend\r\n\tend\r\nend\r\n```\r\n## Variable Scope Revisited\r\n* Existen 4 tipos de Variable \r\n\t- local: comienzan con una letra en minuscula, y es solo accesible en el method que la definio\r\n\t- instance: Comienzan con @ pueden accederse en cualquier method de una instancia de una clase\r\n\t- class: Empiezan con doble @@ estan disponible en cualquier instancia y method de la clase.\r\n\t- global: Comienzan con $ y pueden llamarse en cualquier parte del codigo, se usan en general para los settings.\r\n* Un ejemplo de local Variables seria.\r\n```ruby\r\nclass Square\r\n\r\n\tdef initialize \r\n\t @length = 10 #Declaramos una instance variable \r\n\tend\r\n\r\n\tdef printout \r\n\t\tlength = @lenght * 2 #Declaramos una variable local que es *2 a la instance variable parecieran iguales pero son diferentes. \r\n\t\tputs \"Length = #{length}.\" \r\n\tend  \r\nend \r\n```\r\n* Es importante diferencia que las local variables solo estan disponible entre method.\r\n* Las global variables son buenas para settings globales.\r\n##  Class Methods and Singletons \r\n* Recordemos que la instancia de una clase es para un objeto en especifico de una clase las Class Methods hacen referencia a toda la clase util para operar todos los miembros, variables, o database cleanup methods.\r\n* Creamos una clase pero esta vez creamos un method llamado self.Nombre-del-metodo-que-queramos luego en cualquier lugar de la class podremos llamar al method. \r\n* Para llamar al class method usamos **Class_Name.method_name** ==> Tree.trim \r\n* Los Singleton Methods estan definidos para solo un objecto. \r\n*  Lo definimos luego de crear una variable || objeto luego definimos un metodo con el nombre de la variable seguido del nombre del methodo que creamos.\r\nEjemplo `abc = \"abc\" ---> def abc.twice` \r\n* Tambien es posible usar una Singleton Class util si solo queremos crear una class importante pero unica.\r\n* Existen 2 maneras de crear una Singleton Classes \r\n\t- Crear una blank class y operar en ella.\r\n```ruby\r\n####Creamos una blank class.\r\nclass TableCorporation\r\nend \r\n##Listo sin nada dentro.\r\nclass << TableCorporation \r\n#Todo lo que este dentro sera una singletons class.\r\nend \r\n# -OR-\r\nclass TableCorporation\r\n\tclass << self \r\n\t....##todo lo que este dentro sera una singletons class.\r\n\tend\r\nend\r\n```\r\n\t- Crear una instancia de una clase y extenderla.\r\n```ruby\r\n####Creamos una class.\r\nTableCorporation = Object.new\r\nclass << TableCorporation\r\n....\r\nend \r\n\r\n```\r\n* Vemos que estamos operandolos methods en una clase porque todo en ruby es un object.\r\n* Los attritubes y methods se crear igual que en cualquier otra clase.\r\n* Crear una class para envio de paquetes\r\n```ruby\r\nclass Box\r\n\tattr_accessor :length, :width, :height, :weight, :distance\r\n\tdef initialize\r\n\t@@materials_cost = 0.01 #1 cent per square inch\r\n\t@@rate = 00.1 # 1 cent per pount per mile\r\n\tend \r\n\tdef self.rate= rate\r\n\t@@rate = rate\r\n\tend\r\n\tdef self.materials_cost= cost\r\n\t@@materials_cost = cost\r\n\tend\r\n\tdef package_cost\r\n\t(@length * @width * 2 + @length * @height * 2 + @width * height * 2) * @@materials_cost + @weight * @distance * @@rate \r\n\tend\r\nend\r\n```\r\n* Crear una instancia de una clase y extenderla.\r\n```ruby\r\n####Creamos una class.\r\nTableCorporation = Object.new\r\nclass << TableCorporation\r\n....\r\nend \r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}